
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>NATSORT Examples</title><meta name="generator" content="MATLAB 8.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-01-31"><meta name="DC.source" content="natsort_doc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>NATSORT Examples</h1><!--introduction--><p>The function <a href="https://www.mathworks.com/matlabcentral/fileexchange/34464"><tt>NATSORT</tt></a> sorts the elements of an array (cell/string/categorical) taking into account number values within the text. This is known as <i>natural order</i> or <i>alphanumeric order</i>. Note that MATLAB's inbuilt <a href="https://www.mathworks.com/help/matlab/ref/sort.html"><tt>SORT</tt></a> function sorts text by character code, as does <tt>SORT</tt> in most programming languages.</p><p>To sort filenames, foldernames, or filepaths use <a href="https://www.mathworks.com/matlabcentral/fileexchange/47434"><tt>NATSORTFILES</tt></a>.</p><p>To sort the rows of a string/cell/categorical/table array use <a href="https://www.mathworks.com/matlabcentral/fileexchange/47433"><tt>NATSORTROWS</tt></a>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Basic Usage: Integer Numbers</a></li><li><a href="#2">Input 1: Array to Sort</a></li><li><a href="#3">Input 2: Regular Expression</a></li><li><a href="#4">Input 3+: Case Sensitivity</a></li><li><a href="#5">Input 3+: Sort Direction</a></li><li><a href="#6">Input 3+: Char/Number Order</a></li><li><a href="#7">Input 3+: NaN/Number Order</a></li><li><a href="#8">Input 3+: <tt>SSCANF</tt> Format String (Floating Point, Hexadecimal, Octal, Binary, 64 Bit Integer)</a></li><li><a href="#9">Output 2: Sort Index</a></li><li><a href="#10">Output 3: Debugging Array</a></li><li><a href="#11">Regular Expression: Decimal Fractions, E-notation, +/- Sign</a></li><li><a href="#12">Regular Expression: Hexadecimal, Octal, Binary Integers</a></li><li><a href="#13">Regular Expression: Leading and/or Trailing Whitespace</a></li><li><a href="#14">Bonus: Interactive Regular Expression Tool</a></li></ul></div><h2>Basic Usage: Integer Numbers<a name="1"></a></h2><p>By default <tt>NATSORT</tt> interprets consecutive digits as being part of a single integer, any remaining substrings are treated as text:</p><pre class="codeinput">A = {<span class="string">'a2'</span>, <span class="string">'a10'</span>, <span class="string">'a1'</span>};
sort(A) <span class="comment">% for comparison</span>
natsort(A)
B = {<span class="string">'v9.10'</span>, <span class="string">'v9.5'</span>, <span class="string">'v9.2'</span>, <span class="string">'v9.10.20'</span>, <span class="string">'v9.10.8'</span>};
sort(B) <span class="comment">% for comparison</span>
natsort(B)
</pre><pre class="codeoutput">ans = 
    'a1'    'a10'    'a2'
ans = 
    'a1'    'a2'    'a10'
ans = 
    'v9.10'    'v9.10.20'    'v9.10.8'    'v9.2'    'v9.5'
ans = 
    'v9.2'    'v9.5'    'v9.10'    'v9.10.8'    'v9.10.20'
</pre><h2>Input 1: Array to Sort<a name="2"></a></h2><p>The first input must be one of the following array types:</p><div><ul><li>a cell array of character row vectors,</li><li>a <a href="https://www.mathworks.com/help/matlab/matlab_prog/create-string-arrays.html">string array</a>,</li><li>a <a href="https://www.mathworks.com/help/matlab/categorical-arrays.html">categorical array</a>,</li><li>a <a href="https://www.mathworks.com/help/matlab/ref/datetime.html">datetime array</a>,</li><li>any other array type that can be converted by   <a href="https://www.mathworks.com/help/matlab/ref/cellstr.html"><tt>CELLSTR</tt></a></li></ul></div><p>The sorted array is returned as the first output argument, for example:</p><pre class="codeinput">natsort(categorical(A)) <span class="comment">% see also REORDERCATS</span>
</pre><pre class="codeoutput">ans = 
     a1      a2      a10 
</pre><h2>Input 2: Regular Expression<a name="3"></a></h2><p>The optional second input argument is a regular expression which specifies the number matching (see "Regular Expression" sections below for more examples of regular expressions for matching common numbers):</p><pre class="codeinput">C = {<span class="string">'1.3'</span>,<span class="string">'1.10'</span>,<span class="string">'1.2'</span>};
natsort(C) <span class="comment">% by default match integers.</span>
natsort(C, <span class="string">'\d+\.?\d*'</span>) <span class="comment">% match decimal fractions.</span>
</pre><pre class="codeoutput">ans = 
    '1.2'    '1.3'    '1.10'
ans = 
    '1.10'    '1.2'    '1.3'
</pre><h2>Input 3+: Case Sensitivity<a name="4"></a></h2><p>By default <tt>NATSORT</tt> provides a case-insensitive sort of the array text. An optional input argument selects case-sensitive/insensitive sorting:</p><pre class="codeinput">D = {<span class="string">'a2'</span>, <span class="string">'A20'</span>, <span class="string">'A1'</span>, <span class="string">'a'</span>, <span class="string">'A'</span>, <span class="string">'a10'</span>,<span class="string">'A2'</span>, <span class="string">'a1'</span>};
natsort(D, [], <span class="string">'ignorecase'</span>) <span class="comment">% default</span>
natsort(D, [], <span class="string">'matchcase'</span>)
</pre><pre class="codeoutput">ans = 
    'a'    'A'    'A1'    'a1'    'a2'    'A2'    'a10'    'A20'
ans = 
    'A'    'A1'    'A2'    'A20'    'a'    'a1'    'a2'    'a10'
</pre><h2>Input 3+: Sort Direction<a name="5"></a></h2><p>By default <tt>NATSORT</tt> provides an ascending sort of the array text. An optional input argument selects the sort direction (note that characters and numbers are either both ascending or both descending):</p><pre class="codeinput">E = {<span class="string">'2'</span>, <span class="string">'a'</span>, <span class="string">''</span>, <span class="string">'10'</span>, <span class="string">'B'</span>, <span class="string">'1'</span>};
natsort(E, [], <span class="string">'ascend'</span>) <span class="comment">% default</span>
natsort(E, [], <span class="string">'descend'</span>)
</pre><pre class="codeoutput">ans = 
    ''    '1'    '2'    '10'    'a'    'B'
ans = 
    'B'    'a'    '10'    '2'    '1'    ''
</pre><h2>Input 3+: Char/Number Order<a name="6"></a></h2><p>By default <tt>NATSORT</tt> sorts characters after numbers. An optional input argument selects if characters are treated as <i>greater-than</i> or <i>less-than</i> numbers:</p><pre class="codeinput">natsort(E, [], <span class="string">'num&lt;char'</span>) <span class="comment">% default</span>
natsort(E, [], <span class="string">'char&lt;num'</span>)
</pre><pre class="codeoutput">ans = 
    ''    '1'    '2'    '10'    'a'    'B'
ans = 
    ''    'a'    'B'    '1'    '2'    '10'
</pre><h2>Input 3+: NaN/Number Order<a name="7"></a></h2><p>By default <tt>NATSORT</tt> sorts NaN after all other numbers. An optional input argument selects if NaN are treated as <i>greater-than</i> or <i>less-than</i> numbers:</p><pre class="codeinput">F = {<span class="string">'10'</span>, <span class="string">'1'</span>, <span class="string">'NaN'</span>, <span class="string">'2'</span>};
natsort(F, <span class="string">'NaN|\d+'</span>, <span class="string">'num&lt;NaN'</span>) <span class="comment">% default</span>
natsort(F, <span class="string">'NaN|\d+'</span>, <span class="string">'NaN&lt;num'</span>)
</pre><pre class="codeoutput">ans = 
    '1'    '2'    '10'    'NaN'
ans = 
    'NaN'    '1'    '2'    '10'
</pre><h2>Input 3+: <tt>SSCANF</tt> Format String (Floating Point, Hexadecimal, Octal, Binary, 64 Bit Integer)<a name="8"></a></h2><p>The default format string <tt>'%f'</tt> will correctly parse many common number types: this includes decimal integers, decimal fractions, <tt>NaN</tt>, <tt>Inf</tt>, and numbers written in E-notation. For hexadecimal, octal, binary, and 64-bit integers the format string must be specified as an input argument. Supported <a href="https://www.mathworks.com/help/matlab/ref/sscanf.html"><tt>SSCANF</tt></a> formats are shown in this table:</p><p>
<table>
 <tr><th>Format String</th><th>Number Types</th></tr>
 <tr><td>%e, %f, %g</td>   <td>floating point numbers</td></tr>
 <tr><td>%d</td>           <td>signed decimal</td></tr>
 <tr><td>%i</td>           <td>signed decimal, octal, or hexadecimal</td></tr>
 <tr><td>%ld, %li</td>     <td>signed 64 bit, decimal, octal, or hexadecimal</td></tr>
 <tr><td>%u</td>           <td>unsigned decimal</td></tr>
 <tr><td>%o</td>           <td>unsigned octal</td></tr>
 <tr><td>%x</td>           <td>unsigned hexadecimal</td></tr>
 <tr><td>%lu, %lo, %lx</td><td>unsigned 64-bit decimal, octal, or hexadecimal</td></tr>
 <tr><td>%b</td>           <td>unsigned binary integer (custom parsing, not SSCANF)</td></tr>
</table>
</p><p>For example large integers can be converted to 64-bit numerics, with their full precision:</p><pre class="codeinput">G = {<span class="string">'18446744073709551614'</span>, <span class="string">'18446744073709551615'</span>, <span class="string">'18446744073709551613'</span>};
natsort(G, [], <span class="string">'%lu'</span>)
</pre><pre class="codeoutput">ans = 
    '18446744073709551613'    '18446744073709551614'    '18446744073709551615'
</pre><h2>Output 2: Sort Index<a name="9"></a></h2><p>The second output argument is a numeric array of the sort indices <tt>ndx</tt>, such that <tt>Y = X(ndx)</tt> where <tt>Y = natsort(X)</tt>:</p><pre class="codeinput">H = {<span class="string">'abc2xyz'</span>, <span class="string">'abc10xyz'</span>, <span class="string">'abc2xy99'</span>, <span class="string">'abc1xyz'</span>};
[out,ndx] = natsort(H)
</pre><pre class="codeoutput">out = 
    'abc1xyz'    'abc2xy99'    'abc2xyz'    'abc10xyz'
ndx =
     4     3     1     2
</pre><h2>Output 3: Debugging Array<a name="10"></a></h2><p>The third output is a cell array which contains all matched numbers (after converting to numeric using the specified <tt>SSCANF</tt> format) and all non-number substrings. This cell array is intended for visually confirming that the numbers are being correctly identified by the regular expression. Note that the rows of the debugging cell array are <a href="https://www.mathworks.com/company/newsletters/articles/matrix-indexing-in-matlab.html">linearly indexed</a> from the input array.</p><pre class="codeinput">[~,~,dbg] = natsort(H)
</pre><pre class="codeoutput">dbg = 
    'abc'    [ 2]    'xyz'      []
    'abc'    [10]    'xyz'      []
    'abc'    [ 2]    'xy'     [99]
    'abc'    [ 1]    'xyz'      []
</pre><h2>Regular Expression: Decimal Fractions, E-notation, +/- Sign<a name="11"></a></h2><p><tt>NATSORT</tt> relies on <a href="https://www.mathworks.com/help/matlab/ref/regexpi.html"><tt>REGEXPI</tt></a> to detect numbers in the strings. In order to match the required number format (e.g. decimal fractions, exponents, or a positive/negative sign, etc.) simply provide a suitable <a href="https://www.mathworks.com/help/matlab/matlab_prog/regular-expressions.html">regular expression</a> as an optional input argument:</p><pre class="codeinput">I = {<span class="string">'x+NaN'</span>, <span class="string">'x11.5'</span>, <span class="string">'x-1.4'</span>, <span class="string">'x'</span>, <span class="string">'x-Inf'</span>, <span class="string">'x+0.3'</span>};
sort(I) <span class="comment">% for comparison</span>
natsort(I, <span class="string">'[-+]?(NaN|Inf|\d+\.?\d*)'</span>)
J = {<span class="string">'0.56e007'</span>, <span class="string">''</span>, <span class="string">'43E-2'</span>, <span class="string">'10000'</span>, <span class="string">'9.8'</span>};
sort(J) <span class="comment">% for comparison</span>
natsort(J, <span class="string">'\d+\.?\d*(E[-+]?\d+)?'</span>)
</pre><pre class="codeoutput">ans = 
    'x'    'x+0.3'    'x+NaN'    'x-1.4'    'x-Inf'    'x11.5'
ans = 
    'x'    'x-Inf'    'x-1.4'    'x+0.3'    'x11.5'    'x+NaN'
ans = 
    ''    '0.56e007'    '10000'    '43E-2'    '9.8'
ans = 
    ''    '43E-2'    '9.8'    '10000'    '0.56e007'
</pre><h2>Regular Expression: Hexadecimal, Octal, Binary Integers<a name="12"></a></h2><p>Integers encoded in hexadecimal, octal, or binary may also be parsed and sorted correctly. This requires both an appropriate regular expression to detect the integers and also a suitable <tt>SSCANF</tt> format string for converting the detected number string into numeric:</p><pre class="codeinput">K = {<span class="string">'a0X7C4z'</span>, <span class="string">'a0X5z'</span>, <span class="string">'a0X18z'</span>, <span class="string">'a0XFz'</span>};
sort(K) <span class="comment">% for comparison</span>
natsort(K, <span class="string">'0X[0-9A-F]+'</span>, <span class="string">'%x'</span>) <span class="comment">% hexadecimal</span>
L = {<span class="string">'a11111000100z'</span>, <span class="string">'a101z'</span>, <span class="string">'a000000000011000z'</span>, <span class="string">'a1111z'</span>};
sort(L) <span class="comment">% for comparison</span>
natsort(L, <span class="string">'[01]+'</span>, <span class="string">'%b'</span>) <span class="comment">% binary</span>
</pre><pre class="codeoutput">ans = 
    'a0X18z'    'a0X5z'    'a0X7C4z'    'a0XFz'
ans = 
    'a0X5z'    'a0XFz'    'a0X18z'    'a0X7C4z'
ans = 
    'a000000000011000z'    'a101z'    'a11111000100z'    'a1111z'
ans = 
    'a101z'    'a1111z'    'a000000000011000z'    'a11111000100z'
</pre><h2>Regular Expression: Leading and/or Trailing Whitespace<a name="13"></a></h2><p>Sometimes it may be useful to match numbers <i>ignoring</i> any leading and/or trailing whitespace, this can be achieved by prepending/appending <tt>'\s*'</tt> as required to the regular expression, for example:</p><pre class="codeinput">M = [<span class="string">' 9'</span>;<span class="string">'23'</span>;<span class="string">'10'</span>;<span class="string">' 0'</span>;<span class="string">'5 '</span>] <span class="comment">% character matrix.</span>
natsort(M) <span class="comment">% default matches only digits, whitespace is significant.</span>
natsort(M,<span class="string">'\s*\d+\s*'</span>) <span class="comment">% match and ignore whitespace.</span>
</pre><pre class="codeoutput">M =
 9
23
10
 0
5 
ans =
5 
10
23
 0
 9
ans =
 0
5 
 9
10
23
</pre><h2>Bonus: Interactive Regular Expression Tool<a name="14"></a></h2><p>Regular expressions are powerful and compact, but getting them right is not always easy. One assistance is to download my interactive tool <a href="https://www.mathworks.com/matlabcentral/fileexchange/48930"><tt>IREGEXP</tt></a>, which lets you quickly try different regular expressions and see all of <a href="https://www.mathworks.com/help/matlab/ref/regexp.html"><tt>REGEXP</tt></a>'s outputs displayed and updated as you type.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% NATSORT Examples
% The function <https://www.mathworks.com/matlabcentral/fileexchange/34464
% |NATSORT|> sorts the elements of an array (cell/string/categorical)
% taking into account number values within the text. This is known as
% _natural order_ or _alphanumeric order_. Note that MATLAB's inbuilt
% <https://www.mathworks.com/help/matlab/ref/sort.html |SORT|> function
% sorts text by character code, as does |SORT| in most programming languages.
%
% To sort filenames, foldernames, or filepaths use
% <https://www.mathworks.com/matlabcentral/fileexchange/47434 |NATSORTFILES|>.
%
% To sort the rows of a string/cell/categorical/table array use
% <https://www.mathworks.com/matlabcentral/fileexchange/47433 |NATSORTROWS|>.
%
%% Basic Usage: Integer Numbers
% By default |NATSORT| interprets consecutive digits as being part of a
% single integer, any remaining substrings are treated as text:
A = {'a2', 'a10', 'a1'};
sort(A) % for comparison
natsort(A)
B = {'v9.10', 'v9.5', 'v9.2', 'v9.10.20', 'v9.10.8'};
sort(B) % for comparison
natsort(B)
%% Input 1: Array to Sort
% The first input must be one of the following array types:
%
% * a cell array of character row vectors,
% * a <https://www.mathworks.com/help/matlab/matlab_prog/create-string-arrays.html string array>,
% * a <https://www.mathworks.com/help/matlab/categorical-arrays.html categorical array>,
% * a <https://www.mathworks.com/help/matlab/ref/datetime.html datetime array>,
% * any other array type that can be converted by 
%   <https://www.mathworks.com/help/matlab/ref/cellstr.html |CELLSTR|>
%
% The sorted array is returned as the first output argument, for example:
natsort(categorical(A)) % see also REORDERCATS
%% Input 2: Regular Expression
% The optional second input argument is a regular expression which
% specifies the number matching (see "Regular Expression" sections below
% for more examples of regular expressions for matching common numbers):
C = {'1.3','1.10','1.2'};
natsort(C) % by default match integers.
natsort(C, '\d+\.?\d*') % match decimal fractions.
%% Input 3+: Case Sensitivity
% By default |NATSORT| provides a case-insensitive sort of the array text.
% An optional input argument selects case-sensitive/insensitive sorting:
D = {'a2', 'A20', 'A1', 'a', 'A', 'a10','A2', 'a1'};
natsort(D, [], 'ignorecase') % default
natsort(D, [], 'matchcase')
%% Input 3+: Sort Direction
% By default |NATSORT| provides an ascending sort of the array text.
% An optional input argument selects the sort direction (note that
% characters and numbers are either both ascending or both descending):
E = {'2', 'a', '', '10', 'B', '1'};
natsort(E, [], 'ascend') % default
natsort(E, [], 'descend')
%% Input 3+: Char/Number Order
% By default |NATSORT| sorts characters after numbers.
% An optional input argument selects if characters are treated as
% _greater-than_ or _less-than_ numbers:
natsort(E, [], 'num<char') % default
natsort(E, [], 'char<num')
%% Input 3+: NaN/Number Order
% By default |NATSORT| sorts NaN after all other numbers.
% An optional input argument selects if NaN are treated as
% _greater-than_ or _less-than_ numbers:
F = {'10', '1', 'NaN', '2'};
natsort(F, 'NaN|\d+', 'num<NaN') % default
natsort(F, 'NaN|\d+', 'NaN<num')
%% Input 3+: |SSCANF| Format String (Floating Point, Hexadecimal, Octal, Binary, 64 Bit Integer)
% The default format string |'%f'| will correctly parse many common number
% types: this includes decimal integers, decimal fractions, |NaN|, |Inf|,
% and numbers written in E-notation. For hexadecimal, octal, binary, and
% 64-bit integers the format string must be specified as an input argument.
% Supported <https://www.mathworks.com/help/matlab/ref/sscanf.html
% |SSCANF|> formats are shown in this table:
%
% <html>
% <table>
%  <tr><th>Format String</th><th>Number Types</th></tr>
%  <tr><td>%e, %f, %g</td>   <td>floating point numbers</td></tr>
%  <tr><td>%d</td>           <td>signed decimal</td></tr>
%  <tr><td>%i</td>           <td>signed decimal, octal, or hexadecimal</td></tr>
%  <tr><td>%ld, %li</td>     <td>signed 64 bit, decimal, octal, or hexadecimal</td></tr>
%  <tr><td>%u</td>           <td>unsigned decimal</td></tr>
%  <tr><td>%o</td>           <td>unsigned octal</td></tr>
%  <tr><td>%x</td>           <td>unsigned hexadecimal</td></tr>
%  <tr><td>%lu, %lo, %lx</td><td>unsigned 64-bit decimal, octal, or hexadecimal</td></tr>
%  <tr><td>%b</td>           <td>unsigned binary integer (custom parsing, not SSCANF)</td></tr>
% </table>
% </html>
%
% For example large
% integers can be converted to 64-bit numerics, with their full precision:
G = {'18446744073709551614', '18446744073709551615', '18446744073709551613'};
natsort(G, [], '%lu')
%% Output 2: Sort Index
% The second output argument is a numeric array of the sort indices |ndx|,
% such that |Y = X(ndx)| where |Y = natsort(X)|:
H = {'abc2xyz', 'abc10xyz', 'abc2xy99', 'abc1xyz'};
[out,ndx] = natsort(H)
%% Output 3: Debugging Array
% The third output is a cell array which contains all matched numbers
% (after converting to numeric using the specified |SSCANF| format) and
% all non-number substrings. This cell array is intended for visually
% confirming that the numbers are being correctly identified by the
% regular expression. Note that the rows of the debugging cell array are
% <https://www.mathworks.com/company/newsletters/articles/matrix-indexing-in-matlab.html
% linearly indexed> from the input array.
[~,~,dbg] = natsort(H)
%% Regular Expression: Decimal Fractions, E-notation, +/- Sign
% |NATSORT| relies on <https://www.mathworks.com/help/matlab/ref/regexpi.html
% |REGEXPI|> to detect numbers in the strings. In order to match
% the required number format (e.g. decimal fractions, exponents,
% or a positive/negative sign, etc.) simply provide a suitable
% <https://www.mathworks.com/help/matlab/matlab_prog/regular-expressions.html
% regular expression> as an optional input argument:
I = {'x+NaN', 'x11.5', 'x-1.4', 'x', 'x-Inf', 'x+0.3'};
sort(I) % for comparison
natsort(I, '[-+]?(NaN|Inf|\d+\.?\d*)')
J = {'0.56e007', '', '43E-2', '10000', '9.8'};
sort(J) % for comparison
natsort(J, '\d+\.?\d*(E[-+]?\d+)?')
%% Regular Expression: Hexadecimal, Octal, Binary Integers
% Integers encoded in hexadecimal, octal, or binary may also be parsed and
% sorted correctly. This requires both an appropriate regular expression
% to detect the integers and also a suitable |SSCANF| format string for
% converting the detected number string into numeric:
K = {'a0X7C4z', 'a0X5z', 'a0X18z', 'a0XFz'};
sort(K) % for comparison
natsort(K, '0X[0-9A-F]+', '%x') % hexadecimal
L = {'a11111000100z', 'a101z', 'a000000000011000z', 'a1111z'};
sort(L) % for comparison
natsort(L, '[01]+', '%b') % binary
%% Regular Expression: Leading and/or Trailing Whitespace
% Sometimes it may be useful to match numbers _ignoring_ any leading
% and/or trailing whitespace, this can be achieved by prepending/appending 
% |'\s*'| as required to the regular expression, for example:
M = [' 9';'23';'10';' 0';'5 '] % character matrix.
natsort(M) % default matches only digits, whitespace is significant.
natsort(M,'\s*\d+\s*') % match and ignore whitespace.
%% Bonus: Interactive Regular Expression Tool
% Regular expressions are powerful and compact, but getting them right is
% not always easy. One assistance is to download my interactive tool
% <https://www.mathworks.com/matlabcentral/fileexchange/48930 |IREGEXP|>,
% which lets you quickly try different regular expressions and see all of
% <https://www.mathworks.com/help/matlab/ref/regexp.html |REGEXP|>'s
% outputs displayed and updated as you type.
##### SOURCE END #####
--></body></html>